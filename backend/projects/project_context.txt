Project Context From: /home/atabong/Documents/projet/Odoo Migration Auditor v1/backend/projects
Generated On: sam. 01 nov. 2025 11:37:51 CET
===============================================
Ignored Directory Patterns: .* node_modules vendor build dist target __pycache__ .next cache target venv storage
Ignored File Patterns: *.log *.jar *.pdf *.png *.jpg *.class *.sqlite *.csv project_context.txt package-lock.json yarn.lock composer.lock *.ico pnpm-lock.yaml
===============================================

//---> PATH: /home/atabong/Documents/projet/Odoo Migration Auditor v1/backend/projects/admin.py

from django.contrib import admin

# Register your models here.
# projects/admin.py

from django.contrib import admin
from .models import Project, AnalysisRun,  Issue

# Pour ces modèles, on n'a pas besoin de configuration complexe pour l'instant.
# On les enregistre simplement. Django leur créera une interface par défaut.
admin.site.register(Project)
admin.site.register(AnalysisRun)
admin.site.register(Issue)// END OF FILE: admin.py

//---> PATH: /home/atabong/Documents/projet/Odoo Migration Auditor v1/backend/projects/apps.py

from django.apps import AppConfig


class ProjectsConfig(AppConfig):
    default_auto_field = 'django.db.models.BigAutoField'
    name = 'projects'
// END OF FILE: apps.py

//---> PATH: /home/atabong/Documents/projet/Odoo Migration Auditor v1/backend/projects/__init__.py

// END OF FILE: __init__.py

//---> PATH: /home/atabong/Documents/projet/Odoo Migration Auditor v1/backend/projects/migrations/0001_initial.py

# Generated by Django 5.2.7 on 2025-10-24 15:54

import uuid
from django.db import migrations, models


class Migration(migrations.Migration):

    initial = True

    dependencies = [
    ]

    operations = [
        migrations.CreateModel(
            name='AnalysisRun',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('status', models.CharField(choices=[('PENDING', 'Pending')], default='PENDING', max_length=10)),
                ('created_at', models.DateTimeField(auto_now_add=True)),
            ],
        ),
        migrations.CreateModel(
            name='Project',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('name', models.CharField(max_length=200)),
                ('api_key', models.UUIDField(default=uuid.uuid4, editable=False, unique=True)),
                ('created_at', models.DateTimeField(auto_now_add=True)),
            ],
        ),
    ]
// END OF FILE: migrations/0001_initial.py

//---> PATH: /home/atabong/Documents/projet/Odoo Migration Auditor v1/backend/projects/migrations/0002_initial.py

# Generated by Django 5.2.7 on 2025-10-24 15:54

import django.db.models.deletion
from django.conf import settings
from django.db import migrations, models


class Migration(migrations.Migration):

    initial = True

    dependencies = [
        ('projects', '0001_initial'),
        migrations.swappable_dependency(settings.AUTH_USER_MODEL),
    ]

    operations = [
        migrations.AddField(
            model_name='project',
            name='owner',
            field=models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, related_name='projects', to=settings.AUTH_USER_MODEL),
        ),
        migrations.AddField(
            model_name='analysisrun',
            name='project',
            field=models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, related_name='analysis_runs', to='projects.project'),
        ),
    ]
// END OF FILE: migrations/0002_initial.py

//---> PATH: /home/atabong/Documents/projet/Odoo Migration Auditor v1/backend/projects/migrations/0003_issue.py

# Generated by Django 5.2.7 on 2025-10-24 18:34

import django.db.models.deletion
from django.db import migrations, models


class Migration(migrations.Migration):

    dependencies = [
        ('projects', '0002_initial'),
    ]

    operations = [
        migrations.CreateModel(
            name='Issue',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('severity', models.CharField(choices=[('CRITICAL', 'Critical'), ('MAJOR', 'Major'), ('MINOR', 'Minor'), ('INFO', 'Info')], default='INFO', max_length=10)),
                ('module_name', models.CharField(max_length=100)),
                ('file_path', models.CharField(max_length=255)),
                ('line_number', models.PositiveIntegerField(blank=True, null=True)),
                ('description', models.TextField()),
                ('code_snippet', models.TextField(blank=True)),
                ('analysis_run', models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, related_name='issues', to='projects.analysisrun')),
            ],
        ),
    ]
// END OF FILE: migrations/0003_issue.py

//---> PATH: /home/atabong/Documents/projet/Odoo Migration Auditor v1/backend/projects/migrations/0004_analysisrun_completed_at_alter_analysisrun_status.py

# Generated by Django 5.2.7 on 2025-10-24 19:08

from django.db import migrations, models


class Migration(migrations.Migration):

    dependencies = [
        ('projects', '0003_issue'),
    ]

    operations = [
        migrations.AddField(
            model_name='analysisrun',
            name='completed_at',
            field=models.DateTimeField(blank=True, null=True),
        ),
        migrations.AlterField(
            model_name='analysisrun',
            name='status',
            field=models.CharField(choices=[('PENDING', 'Pending'), ('RUNNING', 'Running'), ('COMPLETED', 'Completed'), ('FAILED', 'Failed')], default='PENDING', max_length=10),
        ),
    ]
// END OF FILE: migrations/0004_analysisrun_completed_at_alter_analysisrun_status.py

//---> PATH: /home/atabong/Documents/projet/Odoo Migration Auditor v1/backend/projects/migrations/0005_project_git_url.py

# Generated by Django 5.2.7 on 2025-10-25 12:24

from django.db import migrations, models


class Migration(migrations.Migration):

    dependencies = [
        ('projects', '0004_analysisrun_completed_at_alter_analysisrun_status'),
    ]

    operations = [
        migrations.AddField(
            model_name='project',
            name='git_url',
            field=models.URLField(blank=True, null=True),
        ),
    ]
// END OF FILE: migrations/0005_project_git_url.py

//---> PATH: /home/atabong/Documents/projet/Odoo Migration Auditor v1/backend/projects/migrations/__init__.py

// END OF FILE: migrations/__init__.py

//---> PATH: /home/atabong/Documents/projet/Odoo Migration Auditor v1/backend/projects/models.py

from django.db import models

# Create your models here.
import uuid
from django.db import models
from django.conf import settings

class Project(models.Model):
    name = models.CharField(max_length=200)
    owner = models.ForeignKey(settings.AUTH_USER_MODEL, on_delete=models.CASCADE, related_name='projects')
    git_url = models.URLField(max_length=200, blank=True, null=True)
    api_key = models.UUIDField(default=uuid.uuid4, editable=False, unique=True)
    created_at = models.DateTimeField(auto_now_add=True)
    def __str__(self): return self.name

class AnalysisRun(models.Model):
    class StatusChoices(models.TextChoices):
        PENDING = 'PENDING', 'Pending'
        RUNNING = 'RUNNING', 'Running'
        COMPLETED = 'COMPLETED', 'Completed'
        FAILED = 'FAILED', 'Failed'
    project = models.ForeignKey(Project, on_delete=models.CASCADE, related_name='analysis_runs')
    status = models.CharField(max_length=10, choices=StatusChoices.choices, default=StatusChoices.PENDING)
    created_at = models.DateTimeField(auto_now_add=True)
    completed_at = models.DateTimeField(null=True, blank=True)

    def __str__(self):
        return f"Analysis for {self.project.name} at {self.created_at.strftime('%Y-%m-%d %H:%M')}"


class Issue(models.Model):
    class SeverityChoices(models.TextChoices):
        CRITICAL = 'CRITICAL', 'Critical'
        MAJOR = 'MAJOR', 'Major'
        MINOR = 'MINOR', 'Minor'
        INFO = 'INFO', 'Info'

    analysis_run = models.ForeignKey(
        AnalysisRun,
        on_delete=models.CASCADE,
        related_name='issues'
    )
    severity = models.CharField(
        max_length=10,
        choices=SeverityChoices.choices,
        default=SeverityChoices.INFO
    )
    module_name = models.CharField(max_length=100)
    file_path = models.CharField(max_length=255)
    line_number = models.PositiveIntegerField(null=True, blank=True)
    description = models.TextField()
    code_snippet = models.TextField(blank=True)

    def __str__(self):
        return f"{self.severity} in {self.file_path} (L{self.line_number})"// END OF FILE: models.py

//---> PATH: /home/atabong/Documents/projet/Odoo Migration Auditor v1/backend/projects/permissions.py

# projects/permissions.py

from rest_framework.permissions import BasePermission

class IsProjectOwner(BasePermission):
    """
    Permission personnalisée pour autoriser uniquement les propriétaires d'un projet.
    """
    def has_object_permission(self, request, view, obj):
        # 'obj' ici est l'instance du projet.
        # On vérifie si le propriétaire de l'objet est l'utilisateur qui fait la requête.
        return obj.owner == request.user

class IsAnalysisOwner(BasePermission):
    """
    Permission personnalisée pour les objets liés à un projet (comme AnalysisRun).
    """
    def has_object_permission(self, request, view, obj):
        # 'obj' ici est l'instance de l'AnalysisRun.
        # On vérifie via la relation ForeignKey.
        return obj.project.owner == request.user// END OF FILE: permissions.py

//---> PATH: /home/atabong/Documents/projet/Odoo Migration Auditor v1/backend/projects/prompter.sh

#!/bin/bash

# --- Configuration ---

# Default project path if none provided
DEFAULT_PROJECT_PATH="."
PROJECT_PATH=${1:-"$DEFAULT_PROJECT_PATH"}

# Output file name (relative to PROJECT_PATH)
OUTPUT_FILENAME="project_context.txt"

# Directories to completely ignore (won't be traversed)
EXCLUDE_DIRS_PATTERN=( \
    ".*"            # All hidden folders (.git, .vscode, .idea, .svn, etc.)
    "node_modules"
    "vendor"        # PHP Composer
    "build"
    "dist"
    "target"        # Java/Rust build outputs
    "__pycache__"   # Python cache
    ".next"         # Next.js build output
    "cache"         # General cache folders
    "target"
    "venv"
    "storage"       # Laravel storage (often contains logs, cache, etc.)
    # Add more directory names here if needed
)

# Specific file patterns to ignore within traversed directories
EXCLUDE_FILES_PATTERN=( \
    "*.log"
    "*.jar"
    "*.pdf"
    "*.png"
    "*.jpg"
    "*.class"
    "*.sqlite"
    "*.csv"
    "project_context.txt"
    # ".env*"       # Consider if you NEED .env files; uncomment if NOT needed.
    "package-lock.json"
    "yarn.lock"
    "composer.lock"
    "*.ico"
    "pnpm-lock.yaml"
    # Add more file patterns here (e.g., "*.swp", "*.bak", "*.tmp")
)

# --- Script Logic ---

# Attempt to get absolute path; exit if PROJECT_PATH is invalid early
PROJECT_PATH=$(realpath "$PROJECT_PATH" 2>/dev/null)
if [ $? -ne 0 ] || [ ! -d "$PROJECT_PATH" ]; then
    echo "Error: Invalid or non-existent project directory specified." >&2 # Error to stderr
    exit 1
fi

OUTPUT_FILE="$PROJECT_PATH/$OUTPUT_FILENAME"

# --- Safety Check: Prevent overwriting the project directory itself ---
# This is unlikely but guards against strange configurations
if [ "$PROJECT_PATH" == "$OUTPUT_FILE" ]; then
    echo "Error: Project directory path conflicts with output file name '$OUTPUT_FILENAME'." >&2
    exit 1
fi

# Delete output file silently if it exists
rm -f "$OUTPUT_FILE"

# --- Build the find command ---
# Uses arrays to construct the find command safely and avoid complex escaping issues with eval
find_args=("$PROJECT_PATH")

# Add directory prune conditions
if [ ${#EXCLUDE_DIRS_PATTERN[@]} -gt 0 ]; then
    find_args+=(\()
    first_prune=true
    for dir_pattern in "${EXCLUDE_DIRS_PATTERN[@]}"; do
        if ! $first_prune; then
            find_args+=(-o)
        fi
        find_args+=(-name "$dir_pattern" -type d)
        first_prune=false
    done
    find_args+=(\) -prune -o) # Add the prune action and the OR for the next part
fi

# Add primary find conditions (type file, exclude output file, exclude patterns)
find_args+=(\( -type f -not -path "$OUTPUT_FILE")
if [ ${#EXCLUDE_FILES_PATTERN[@]} -gt 0 ]; then
    for file_pattern in "${EXCLUDE_FILES_PATTERN[@]}"; do
        find_args+=(-not -name "$file_pattern")
    done
fi
find_args+=(-print \)) # Add the print action and close the group

# --- Execute the find command and process results ---

# Create the header in the output file
{
    echo "Project Context From: $PROJECT_PATH"
    echo "Generated On: $(date)"
    echo "==============================================="
    echo "Ignored Directory Patterns: ${EXCLUDE_DIRS_PATTERN[*]}"
    echo "Ignored File Patterns: ${EXCLUDE_FILES_PATTERN[*]}"
    echo "==============================================="
    echo ""
} > "$OUTPUT_FILE"

error_count=0
# Use find with process substitution and sorting. Avoids eval.
while IFS= read -r FILE_PATH; do
    # Calculate relative path for cleaner output
    RELATIVE_PATH="${FILE_PATH#"$PROJECT_PATH"/}"

    # Append file info and content to the output file
    {
        # echo ""
        # echo "// ==============================================="
        # echo "---> FILE: $RELATIVE_PATH"
        echo "//---> PATH: $FILE_PATH"
        # echo "// ==============================================="
        echo ""
    } >> "$OUTPUT_FILE"

    # Check if file is likely binary/non-text using 'file' command
    # -b: omit filename; check for common non-text types
    if file -b "$FILE_PATH" | grep -q -E 'binary|archive|compressed|image|font'; then
        echo "[Non-text file (e.g., binary, data, compressed) - Contents omitted]" >> "$OUTPUT_FILE"
    else
        # Append text file content, redirect cat errors to stderr
        if ! cat "$FILE_PATH" >> "$OUTPUT_FILE" 2> /dev/null; then # Hide cat errors from stdout
             # Optionally log error to the output file itself, or just count it
             echo "[Error reading file content for $RELATIVE_PATH]" >> "$OUTPUT_FILE"
             ((error_count++))
        fi
    fi

    {
        # echo ""
        echo "// END OF FILE: $RELATIVE_PATH"
        echo ""
    } >> "$OUTPUT_FILE"

done < <(find "${find_args[@]}" | sort) # Execute find command using safe array expansion

# Optionally report errors to stderr if any occurred
if [ $error_count -gt 0 ]; then
    echo "Warning: Encountered $error_count errors reading file contents during context generation." >&2
    # Exit with a non-zero status to indicate partial success/warning
    exit 1
fi

# Exit silently on success
exit 0
// END OF FILE: prompter.sh

//---> PATH: /home/atabong/Documents/projet/Odoo Migration Auditor v1/backend/projects/serializers.py

# projects/serializers.py

from rest_framework import serializers
from .models import Project, AnalysisRun, Issue



class AnalysisRunListSerializer(serializers.ModelSerializer):
    class Meta:
        model = AnalysisRun
        fields = ['id', 'status', 'created_at']


class ProjectSerializer(serializers.ModelSerializer):
    analysis_runs = AnalysisRunListSerializer(many=True, read_only=True)
    
    class Meta:
        model = Project
        # On ne change que cette ligne
        fields = ['id', 'name', 'owner', 'git_url', 'api_key', 'created_at', 'analysis_runs']
        read_only_fields = ['owner']

class IssueSerializer(serializers.ModelSerializer):
    class Meta:
        model = Issue
        fields = [
            'id', 'severity', 'module_name', 'file_path', 
            'line_number', 'description', 'code_snippet'
        ]


class AnalysisRunDetailSerializer(serializers.ModelSerializer):
    # C'est ici que la magie opère.
    # On déclare un champ 'issues' qui utilisera notre IssueSerializer.
    # many=True indique qu'il s'agit d'une liste de plusieurs objets.
    # read_only=True signifie que ce champ sera seulement lu, pas écrit via ce serializer.
    issues = IssueSerializer(many=True, read_only=True)

    class Meta:
        model = AnalysisRun
        fields = [
            'id', 'project', 'status', 'created_at', 
            'completed_at', 'issues' 
        ]




class AnalysisRunCreateSerializer(serializers.ModelSerializer):
    # On redéfinit 'issues' pour qu'il soit inscriptible (writeable).
    # On utilise le 'slug' du serializer d'Issue que nous avons déjà, 
    # mais on enlève 'read_only=True'.
    issues = IssueSerializer(many=True)

    class Meta:
        model = AnalysisRun
        # On ne demande que le project_id et la liste des issues à l'agent.
        # Le statut et les dates seront gérés automatiquement.
        fields = ['project', 'issues']

    def create(self, validated_data):
        """
        On surcharge la méthode create pour gérer la création imbriquée.
        """
        # On extrait les données des 'issues' du dictionnaire validé.
        issues_data = validated_data.pop('issues')
        
        # On crée d'abord l'objet parent 'AnalysisRun'.
        # On passe directement le reste des données validées (ici, juste 'project').
        analysis_run = AnalysisRun.objects.create(**validated_data)
        
        # Ensuite, on boucle sur chaque 'issue' reçue...
        for issue_data in issues_data:
            # ...et on crée l'objet Issue en le liant à l'AnalysisRun parent.
            Issue.objects.create(analysis_run=analysis_run, **issue_data)
            
        return analysis_run// END OF FILE: serializers.py

//---> PATH: /home/atabong/Documents/projet/Odoo Migration Auditor v1/backend/projects/tests.py

from django.test import TestCase

# Create your tests here.
// END OF FILE: tests.py

//---> PATH: /home/atabong/Documents/projet/Odoo Migration Auditor v1/backend/projects/urls.py

# projects/urls.py
from django.urls import path
from rest_framework.routers import DefaultRouter
from .views import ProjectViewSet, AnalysisRunViewSet, AnalysisRunCreateView

router = DefaultRouter()
# On enregistre notre ViewSet auprès du routeur.
# 'projects' sera la base de l'URL (ex: /api/projects/)
router.register(r'projects', ProjectViewSet, basename='project')
router.register(r'analyses', AnalysisRunViewSet, basename='analysis')
urlpatterns = router.urls

urlpatterns = router.urls + [
    # Cette ligne définit l'URL pour la soumission d'analyse.
    path('submit-analysis/', AnalysisRunCreateView.as_view(), name='submit-analysis'),
]// END OF FILE: urls.py

//---> PATH: /home/atabong/Documents/projet/Odoo Migration Auditor v1/backend/projects/views.py

from django.shortcuts import render
import uuid
from rest_framework import viewsets, generics
from rest_framework.decorators import action
from rest_framework.response import Response
from rest_framework.permissions import IsAuthenticated 
from rest_framework.exceptions import PermissionDenied
from .models import Project, AnalysisRun
from .serializers import ProjectSerializer, AnalysisRunDetailSerializer,  AnalysisRunCreateSerializer
from .permissions import IsProjectOwner, IsAnalysisOwner

class ProjectViewSet(viewsets.ModelViewSet):
    serializer_class = ProjectSerializer
    permission_classes = [IsAuthenticated, IsProjectOwner]

    def get_queryset(self):
        return Project.objects.filter(owner=self.request.user)

    def perform_create(self, serializer):
            """
            Associe automatiquement l'utilisateur connecté comme propriétaire du projet.
            """
            # request.user est l'utilisateur authentifié grâce au token.
            serializer.save(owner=self.request.user)

    @action(detail=True, methods=['get'], url_path='latest-analysis')
    def latest_analysis(self, request, pk=None):
        """
        Endpoint personnalisé pour récupérer la dernière analyse d'un projet spécifique.
        URL générée : GET /api/projects/{pk}/latest-analysis/
        """
        # 1. On récupère le projet de manière sécurisée (vérifie que l'utilisateur est propriétaire)
        project = self.get_object()
        
        # 2. On cherche la dernière analyse liée à ce projet
        # .order_by('-created_at') trie de la plus récente à la plus ancienne
        # .first() prend la première de la liste (donc la plus récente)
        latest_run = project.analysis_runs.order_by('-created_at').first()

        # 3. Si aucune analyse n'existe, on renvoie une 404
        if not latest_run:
            return Response(
                {"detail": "Aucune analyse trouvée pour ce projet."}, 
                status=404
            )

        # 4. Sinon, on sérialise et on renvoie la réponse
        serializer = AnalysisRunDetailSerializer(latest_run)
        return Response(serializer.data)

    @action(detail=True, methods=['post'], url_path='regenerate-api-key')
    def regenerate_api_key(self, request, pk=None):
        """
        Génère une nouvelle clé API pour le projet.
        """
        # self.get_object() garantit que seul le propriétaire peut accéder à cette action.
        project = self.get_object()
        
        # On génère une nouvelle clé UUID et on sauvegarde le projet.
        project.api_key = uuid.uuid4()
        project.save()
        
        # On renvoie une réponse avec la nouvelle clé.
        return Response({'api_key': project.api_key})
    

class AnalysisRunViewSet(viewsets.ReadOnlyModelViewSet):
    """
    Vue pour lister et récupérer les détails des analyses.
    ReadOnlyModelViewSet ne permet que les opérations de lecture (pas de création/modif ici).
    """
    serializer_class = AnalysisRunDetailSerializer
    permission_classes = [IsAuthenticated, IsAnalysisOwner]

    def get_queryset(self):
        """
        On s'assure que l'utilisateur ne peut voir que les analyses
        des projets qui lui appartiennent.
        """
        return AnalysisRun.objects.filter(project__owner=self.request.user)


class AnalysisRunCreateView(generics.CreateAPIView):
    """
    Vue dédiée à la création d'une nouvelle analyse par l'agent CLI.
    """
    queryset = AnalysisRun.objects.all()
    serializer_class = AnalysisRunCreateSerializer
    permission_classes = [IsAuthenticated] # Seul un utilisateur authentifié peut soumettre une analyse

    def perform_create(self, serializer):
        """
        Cette méthode est appelée juste avant de sauvegarder le nouvel objet.
        On s'assure que le projet auquel l'analyse est liée appartient bien
        à l'utilisateur qui fait la requête. C'est une mesure de sécurité cruciale.
        """
        project = serializer.validated_data['project']
        if project.owner != self.request.user:
            raise PermissionDenied("Vous n'êtes pas autorisé à ajouter une analyse à ce projet.")
        
        # Si la vérification est OK, on procède à la sauvegarde normale.
        serializer.save()// END OF FILE: views.py

